\section{Criptografía con curvas elípticas con Python}
\label{sec:Criptografía con curvas elípticas con Python}

En esta sección se explica el programa desarollado \emph{Criptografía con Curvas Elípticas con Python} o \emph{ccecpy}. Este programa permite trabajar con el grupo de puntos de una curva elíptica y desarrollar protocolos criptográficos que usen curvas elípticas.

% TODO: + intro
% TODO: ref
Puede consultar el código fuente en~\ref{}. La documentación en formato de página web se adjutará a este documento.

\subsection{Motivación}
\label{sub:Motivación}

Existen diversos software de álgebra computacional que permiten hacer cálculos sobre curvas elípticas. \cite{Washington:2008} muestra como usar algunos de los principales ejemplos en este ámbito como Pari, Magma y Sage.

% TODO: ref
El principal motivo para implementar un programa y no utilizar uno ya existente ha sido para aplicar los conceptos aprendidos en el desarrollo matemático~\ref{} e implementar los algoritmos estudiados en el desarrollo informático~\ref{}. Sin embargo, y no menos importante, otro motivo era crear un programa libre y gratuito,
fácil de entender y extender y con una documentación extensa en español.

A diferencia de grandes soluciones como Magma o Sage, ccepy es framework \emph{minimalista}, es decir, provee un conjunto de funcionalidades imprescindibles para cualquiera que desee trabajar con curvas elípticas y a partir de dichas funcionalidades es muy fácil añadir nuevas mejoras. Además, dichas funcionalidades se han implementado siguiendo un diseño lo más simple posible, de tal forma que entender el programa en su totalidad requiere un esfuerzo mínimo comparado con otros software.

\subsection{Herramientras utilizadas}
\label{sub:Herramientras utilizadas}

% TODO: rellenar ref
Se ha utilizado \emph{python 3} como lenguaje de programación para ccepy. La lógica del programa no usa ninguna biblioteca externa, solo se utiliza la biblioteca estándar de python. Por eso, con tener python instalado es suficiente para usar ccepy. En ~\ref{} se detalla como usar este programa.

% TODO: ref
Para realizar la documentación se ha utilizado el software \emph{sphinx} que permite generar páginas web y documentos en formato latex a partir del código fuente y fichero en formato \emph{reStructuredText}. El proceso de documentación se ha detallado en~\ref{}.

% TODO: ref
Para realizar tests basados en propiedades (véase ~\ref{}) se ha utilizado la biblioteca \emph{hypothesis} que permite generar múltiples test unitarios a partir de una especificación de propiedades.

\subsection{Arquitectura}
\label{sub:Arquitectura}

El software ccepy consta de cinco módulos:

\begin{itemize}
    \item Aritmética elemental.
    \item Cuerpos finitos.
    \item Curvas elípticas.
    \item Esquemas criptográficos.
    \item Listado de curvas elípticas.
\end{itemize}

Excepto el último módulo, cada uno está contenido en el anterior, en el sentido que el módulo de cuerpos finitos usa el de aritmética elemental, el módulo de curvas elípticas usa el módulo de cuerpos finitos (y en consecuencia el de aritmética elemental) y el módulo de esquemas criptográficos usa el módulo de curvas elípticas (y en consecuencia el de cuerpos finitos y aritmética elemental).

% TODO: ref
Explicaremos la implementación de cada módulo en ~\ref{} y como usarlo en~\ref{}.

\subsection{Implementación}
\label{sub:Implementación}

% TODO: documentación, ref algoritmos no triviales, estructura de datos
Para implementar ccepy hemos seguido un diseño orientado a objetos ya que los elementos algebraicos que queremos implementar (enteros módulo un primo, elementos de un cuerpo finito, puntos de una curva elítipca) se pueden manejar muy bien representándolos como objetos y clases.

% TODO: ver si hay que actualiar
La estructura en directorios es la siguiente:
\begin{verbatim}
    ccepy/
        ccepy/
        docs/
        tests/
\end{verbatim}
La carpeta \code{ccepy/ccepy} contiene el código fuente los módulos listados en~\ref{sub:Arquitectura}, \code{ccepy/docs} contiene la documentación y el código que la genera y por último \code{ccepy/tests} contiene las pruebas unitarias y basadas en propiedades.

% TODO: ref
El objetivo final es conseguir implementar los protocolos criptográficos explicados en~\ref{}. Por ello, explicaremos primero lo más esencial, el módulo de aritmética elemental.
% que nos permitirá implementar los cuerpos finitos y posteriormente el grupo de puntos de una curva elíptica.

\begin{nota}
    Este apartado \emph{no} es la documentación. En esta sección se contarán los detalles técnicos de la implementación como la estructura de datos o lo algoritmos no triviales utilizados. Para ver un listado de las distintas funciones y clases, los atributos y métodos de una clase y cómo usar dichas funciones, clases y módulos, diríjase a la documentación adjunta en formato de página web.
\end{nota}

\subsubsection{Módulo de aritmética elemental}
\label{subs:Módulo de aritmética elemental}

Este módulo permite operar con enteros módulo un primo $p$ y polinomios
cuyos coeficientes sean enteros módulo un primo $p$. El código fuente de este módulo está en el archivo \code{aritmetica\_elemental.py}.

Los enteros módulo un primo se han representado con la clase \code{EnteroModuloP}. Para tener clases distintas para módulos distintos (para que cada clase tengo como atributo de clase el primo con el que se hace el módulo), se ha imitado la filosofía del patrón \emph{factoría}, esto es, hemos creado una función \code{Zp()} que acepta como parámetro un número primo y devuelve la clase que representa los enteros módulo dicho primo. Podemos ver la función \code{Zp} como el constructor de cuerpos $\mathbb{Z}_p$. Esto lo hemos podido hacer ya que python permite definir clases dentro de funciones y devolver definiciones de clases como valor de retorno de una función. Además, hemos utilizado el \emph{decorador} \code{@lru\_cache()} del módulo \code{functools} de la biblioteca estándar de python para que llamadas iguales sucesivas a \code{Zp()} devuelvan el mismo objeto y no se creen copias de una misma clase para un mismo primo.

Además, \code{EnteroModuloP} es subclase del tipo básico \code{int}. Así, hemos implementado los operadores $+$, $-$, $*$, $/$ y $**$ simplemente llamando a dichos operadores ya implementados para el tipo de dato \code{int} y haciendo $\%$ en cada operación. Además, gracias a esta herencia, se permite usar estas operaciones con un dato de tipo \code{EnteroModuloP} y otro de tipo \code{int}, devolviendo el resultado como dato de tipo \code{EnteroModuloP}.

La clase \code{EnteroModuloP} utiliza el \emph{algoritmo extendido de Euclides} para el cálculo de inversos. El algoritmo, extraído de~\cite{Menezes:1996}, es el siguiente:
\begin{algoritmo2}[Algoritmo extendido de Euclides para enteros]
    ENTRADA: dos enteros no negativos $a$ y $b$ con $a \ge b$. \\
    SALIDA: $d = mcd(a, b)$ y enteros $x, y$ satisfaciendo $a x + b y = d$.
    \begin{enumerate}
        \item Si $b = 0$, tomar $d \leftarrow a, \ x \leftarrow 1, \ y \leftarrow 0$ y devolver $(d, x, y)$.
        \item Inicializar $x_2 \leftarrow 1, \ x_1 \leftarrow 0, \ y_2 \leftarrow 0,\ y_1 \leftarrow 1$.
        \item Mientras $b > 0$, hacer lo siguiente:
        \begin{enumerate}
            \item $q \leftarrow \lfloor a/b \rfloor, r \leftarrow a - q b, \ x \leftarrow x_2 - q x_1, \ y \leftarrow y_2 - q y_1$.
            \item $a \leftarrow b, \ b \leftarrow r, \ x_2 \leftarrow x_1, \ x_1 \leftarrow x, \ y_2 \leftarrow y_1$ y $y_1 \leftarrow y$.
        \end{enumerate}
        \item Tomar $d \leftarrow a, \ x \leftarrow x_2, \ y \leftarrow y_2$ y devolver $(d, x, y)$.
    \end{enumerate}
\end{algoritmo2}
Este algoritmo está encapsulado en la función \code{alg\_euclides()}. Así, el cálculo del inverso de un elemento $a \in \mathbb{Z}_p$ se reduce a calcular el algoritmo de Euclides para la pareja $(a, p)$ y el inverso es el coeficiente $x$.

Los polinomios con coeficientes enteros módulo un primo se han representando con la clase \code{PolinomioZp}. Internamente, cada objeto de \code{PolinomioZp} contiene una lista de python de datos de tipo \code{EnteroModuloP} (que representan los coeficientes del polinomio) y un entero (que representa el primo con el que se hizo módulo los coeficientes). La lista se ha definido como una \emph{propiedad} de python para permitir solo los accesos de lectura.

\code{PolinomioZp} implementa los operadores  $+$, $-$, $*$, $/$, $\%$ y $**$ para operar entre polinomios más cómodamente. También se ha implementado el método \code{\_\_hash\_\_()} para poder utilizar posteriormente el decorador \code{\@lru\_cache()} sobre la función \code{Fq()} del módulo de cuerpos finitos ya que este decorador requiere que todos los argumentos de la función sobre la que se aplica tengan como representación un número entero y esta representación debe definirse en el método \code{\_\_hash\_\_()}.

De entre todos los métodos de \code{PolinomioZp}, destacamos \code{es\_irreducible()}. Como este método utiliza el \emph{algoritmo extendido de Euclides para polinomios}, vamos a detallar primero este.
\begin{algoritmo2}[Algoritmo extendido de Euclides para polinomios]
\label{alg:algoritmo extendido de Euclides para polinomios}
    ENTRADA: dos polinomios $g, h \in \mathbb{Z}_p[X]$. \\
    SALIDA: $d = mcd(g, h)$ y polinomios $s, t \in \mathbb{Z}_p[X]$ satisfaciendo $s g + t h= d$.
    \begin{enumerate}
        \item Si $h = 0$, tomar $d \leftarrow g, \ s \leftarrow 1, \ t \leftarrow 0$ y devolver $(d, s, t)$.
        \item Inicializar $s_2 \leftarrow 1, \ s_1 \leftarrow 0, \ t_2 \leftarrow 0,\ t_1 \leftarrow 1$.
        \item Mientras $h \neq 0$, hacer lo siguiente:
        \begin{enumerate}
            \item $q \leftarrow g \textrm{ div } h, \ r \leftarrow g - h q$.
            \item $s \leftarrow s_2 - q s_1, \ t \leftarrow t_2 - q t_1$.
            \item $g \leftarrow h, \ h \leftarrow r$.
            \item $s_2 \leftarrow s_1, \ s_1 \leftarrow s, \ t_2 \leftarrow t_1$ y $t_1 \leftarrow t$.
        \end{enumerate}
        \item Tomar $d \leftarrow g, \ s \leftarrow s_2, \ t \leftarrow t_2$ y devolver $(d, s, t)$.
    \end{enumerate}
\end{algoritmo2}
Este algoritmo está encapsulado en la función \code{alg\_euclides\_polinomios()}. Así pues, el método \code{es\_irreducible()} se encagar de ver si un polinomio es irreducible de manera eficiente en $\mathbb{Z}_p[X]$ y para ello utiliza el siguiente procedimiento.
\begin{algoritmo2}
    ENTRADA: un primo $p$ y un polinomio mónico $f(x)$ de grado $m$ en $\mathbb{Z}_p[X]$. \\
    SALIDA: verdadero o falso según $f(x)$ sea irreducible o no.
    \begin{enumerate}
        \item Inicializar $u(x) \leftarrow x$.
        \item Para $i$ desde 1 hasta $\lfloor m/2 \rfloor$, hacer lo siguiente:
            \begin{enumerate}
                \item Calcular $u(x) \leftarrow u(x)^p \textrm{ mod } f(x)$.
                \item Calcular $d(x) = mcd(f(x), u(x) - x)$ usando el algoritmo~\ref{alg:algoritmo extendido de Euclides para polinomios}.
                \item Si $d(x) \neq 1$, devolver \code{Falso}.
            \end{enumerate}
        \item Devolver \code{Verdadero}.
    \end{enumerate}
\end{algoritmo2}
\begin{nota}
    El algoritmo anterior está basado en los siguientes resultados. Sea $p$ un primo y $k$ un entero.
    \begin{itemize}
        \item El producto de todos los polinomios mónicos irreducibles de $\mathbb{Z}_p[X]$ de grado un divisor de $k$ es igual a $x^{p^k} - x$.
        \item Sea $f(x)$ un polinomio de grado $m$ en $\mathbb{Z}_p[X]$. Entonces $f(x)$ es irreducible en $\mathbb{Z}_p[X]$ si y solo si $mcd(f(x), x^{p^i} - x) = 1$ para cada $i, \ 1 \le i \le \lfloor m/2 \rfloor$.
    \end{itemize}
\end{nota}
Estos dos algoritmos y este par de resultados han sido extraídos de~ \cite{Menezes:1996}.

\subsubsection{Módulo de cuerpos finitos}
\label{subs:Módulo de cuerpos finitos}

Este módulo permite operar con elementos de un cuerpos finito de $q$ elementos, donde $q$ será la potencia de un primo. El código fuente de este módulo está en el archivo \code{cuerpos\_finitos.py}.

Los elementos del cuerpo finito $p$ elementos, con $p$ primo, ya están implementados por la clase \code{EnteroModuloP}. Los elementos del resto de cuerpos finitos, esto es, aquellos con un número de elementos de la forma $q = p^n$ con $n > 1$ se han representado con la clase \code{ElementoFq}. Análogamente a \code{EnteroModuloP}, le hemos asociado una función factoría a \code{ElementoFq}, llamada \code{Fq()}, que devuelve cada clase para cada número de elementos de un cuerpo finito. También hemos utilizado el decorador \code{@lru\_cache()} sobre \code{Fq()} para no tener cuerpos finitos iguales duplicados en memoria.

\code{ElementoFq} es definido como subclase de \code{PolinomioZp} ya que estamos representado los elementos de un cuerpo finito $\Fq = \Fpn$ como polinomios de $\mathbb{Z}_p[X]$ de hasta grado $n-1$. El polinomio irreducible de $\mathbb{Z}_p[X]$ de grado $n$ puede especificarse o no; si no se especifica, se elige un polinomio irreducible aleatorio de grado $n$. Los operadores  $+$, $-$, $*$, $/$ y $**$ se han implementado usando los operadores ya implementados para \code{PolinomioZp}.

Para el cálculo de inversos en $\Fq$ se utiliza el algoritmo de Euclides para polinomios de forma análoga a como se hacía para $\mathbb{Z}$. Para calcular potencias hemos utilizado el \emph{algoritmo de exponenciación binaria}, más eficiente que el algoritmo de multiplicar el elemento consigo mismo. El algoritmo, sacado de~\cite{Menezes:1996}, es el siguiente.
\begin{algoritmo2}
ENTRADA: $g(x) \in \Fpn$, un entero $0 \le k < p^n - 1$ y su representación binaria $k = \sum_{i=0}^{t} k_i 2^i$. \\
SALIDA: $g(x)^k \textrm{ mod } f(x)$.
\begin{enumerate}
    \item Inicializar $s(x) \leftarrow 1$. Si $k = 0$, devolver $s(x)$.
    \item Inicializar $G(x) \leftarrow  g(x)$.
    \item Si $k_0 = 1$, hacer $s(x) \leftarrow  g(x)$.
    \item Para $i$ desde 1 hata $t$, hacer lo siguiente:
    \begin{enumerate}
        \item Calcular $G(x) \leftarrow  G(x)^2 \textrm{ mod } f(x)$.
        \item Si $k_i = 1$, calcular $s(x) \leftarrow G(x) * s(x) \textrm{ mod } f(x)$.
    \end{enumerate}
    \item Devolver $s(x)$.
\end{enumerate}
\end{algoritmo2}
Para obtener la representación binaria de un entero se ha utilizado la función de la biblioteca estándar de python \code{bin()}.

\subsubsection{Módulo de curvas elípticas}
\label{subs:Módulo de curvas elípticas}

Este módulo permite operar con el grupo de puntos de una curva elíptica. El código fuente de este módulo está en el archivo \code{curvas\_elipticas.py}.

Los puntos de una curva elíptca se han representando con distintas clases según el modelo de curva elítipca. Así, hay una clase para el grupo de puntos $E(\Fq)$, con $\Fq$ de característica distinta de 2 y 3, otra clase para $E(\Fm)$ y una última clase para $E(\mathbb{Q})$. Sin embargo, todas heredan de la misma clase y empezaremos por esta clase madre.

La clase \code{PuntoRacional} es una clase \emph{abstracta}. Esta clase define el comportamiento de algunos métodos y deja sin implementar otros (similiar a los métodos \emph{virtuales} de C++). En python, este tipo de clases se crean utilizando la \emph{metaclase} \code{ABCMeta} y el decorador \code{@abstractmethod}, ambos del módulo \emph{abc} de la biblioteca estándar. Así, esta clase define el elemento neutro, que se representa como la tupla \code{(None, None)}, y especifica que los puntos deben representarse con un atributo para la componente $x$ y otro para la componente $y$ y además restringe el acceso para que sea de solo lectura, a través de las propiedades de python. Por último, indica que se deben implementar los métodos \code{contiene} (que evalúa la ecuación de la curva elíptica dado un par de componentes) y los operadores aritméticos básicos.

% TODO: add ref
La clase que representa $E(\Fq)$ es la clase \code{PuntoFqRacional}. Análogamente a \code{EnteroModuloP}, le hemos asociado una función factoría a \code{PuntoFqRacional}, llamada \code{curva\_eliptica\_sobre\_Fq()}, que pasandole como argumentos los coeficientes de la ecuación de Weierstrass~\ref{} y el cuerpo base, devuelve \code{PuntoFqRacional} con sus atributos de clase (los coeficientes de la ecuación, el cuerpo base y el discriminate) inicializados. De esta forma, dos curvas sobre $\Fq$ pero con distinta ecuación (distintos coeficientes) son dos clases distintas.

% TODO: add ref
\code{PuntoFqRacional} crea un punto de la curva pásandole como argumentos la componente $x$ y la componente $y$. Si dicho punto no estuviera en la curva, se lanza una excepción. Además, \code{PuntoFqRacional} implementa los operadores $+$, $-$ y $*$ con su significado natural. Para ello, en los métodos especiales \code{\_\_add\_\_} y \code{\_\_neg\_\_} se incluyen las fórmulas de adicción~\ref{}; el algoritmo eficiente de multiplicación de un punto por un escalar~\ref{} se incluye en el método \code{\_\_mul\_\_}.

Las clases \code{PuntoF2mRacional} y \code{PuntoQRacional} que representan respectivamente a $E(\Fm)$ y $E(\mathbb{Q})$ se han implementado de forma similar a \code{PuntoFqRacional}: se crean mediante una función factoría (\code{curva\_eliptica\_sobre\_F2m} y \code{curva\_eliptica\_sobre\_Q} respectivamente), heredan de \code{PuntoRacional} e implementan los operadores $+$, $-$ y $*$ utilizando las fórmulas de adicción ~\ref{} y \ref{} respectivamente.

La clase \code{PuntoQRacional} se ha implementado para mostrar un ejemplo de una curva elítipca definida sobre un cuerpo distinto a los cuerpos finitos. Se ha utilizado el módulo \code{fractions} de python para representar a los racionales. Esta clase no será utilizada en el siguiente módulo a diferencia de las otras dos clases.

\subsubsection{Módulo de esquemas criptográficos}
\label{subs:Módulo de esquemas criptográficos}

...

\subsection{Pruebas}
\label{sub:Pruebas}

% TODO: pruebas unitarias, hypothesis

\subsection{Generación de la documentación}
\label{sub:Generación de la documentación}

% TODO: sphinx
